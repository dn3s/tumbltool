#!/usr/bin/perl

#    TUMBLTOOL! Test and deploy Tumblr themes with ease!
#    Copyright (C) 2015 Devon Sawatzky.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
use strict;
#use warnings;
use Data::Dumper;
use JSON;
use MIME::Base64;
use Cwd;
use Getopt::Long;
use File::Basename;
use HTML::Strip;
use HTML::Entities;
use URI::Escape;
use Time::Piece;
#use sTre4M oF CoNCiOUsN3SS-StYLe C0mMeENTs (srry);
my $cwd=cwd();
my $home=$ENV{HOME};
my $contentPath=[
	"/etc/tumbltool",
	"$home/.tumbltool",
	"$cwd/example_content",
	"$cwd"
];
my $realContentPath="";
my $command=shift(); #command comes first, not subject to Getopt stuff
my $content='default';
my $dataURI='';
my $include=[];
my $inline='';
my $strip='';
my $theme='';
my $help='';
my $vars={};
#Getopt::Long::Configure("bundling");
GetOptions(
	"include|i=s{1,}" => $include,
	"content|c=s" => \$content,
	"dataURI|d" => \$dataURI,
	"inline|l!" => \$inline,
	"strip|s!" => \$strip,
	"var|v=s%" => \$vars,
	"theme|t=s" => \$theme,
	"help|h|?" => \$help
) or die; #TODO: snag the last arg as theme if it exists
if($command eq "preview") {
	if($dataURI) {
		print("data:text/html;base64,");
		print(encode_base64(render(parseTheme($theme, $strip),parseContent(contentFile($content)),$include,$inline,$strip),""));
	}
	else {
		print(render(parseTheme($theme, $strip),parseContent(contentFile($content)),$include,$inline,$strip));
	}
	print("\n");
}
elsif($command eq "bundle") {
	print(bundle(parseTheme($theme, $strip),$include,$inline,$strip));
	print("\n");
}
elsif($command eq "help") {
	fail();
}
elsif($command eq "") {
	fail("No command spefified!");
}
else {
	fail("Unknown command: \"$command\"\n");
}

sub contentFile
{
	my $in=shift();
	if($in=~/^\//) {
		$realContentPath=dirname($in);
		return $in;
	}
	elsif($in=~/\.json$/) {
		$realContentPath="$cwd";
		return "$cwd/$in";
	}
	else {
		foreach my $dir (@{$contentPath}) {
			if(-e "$dir/$in.json") {
				$realContentPath="$dir";
				return "$dir/$in.json";
			}
			elsif(-e "$dir/$in/data.json") {
				$realContentPath="$dir/$in";
				return "$dir/$in/data.json";
			}
		}
	}
	return "";
}
sub path
{
	my $in=shift();
	return ($in=~/^\//)?$in:"$cwd/$in";
}
sub slurp #yum. needed both by parseTheme and parseContent (unless there's a way to make the JSON parser work without slurping)
{
	(my $filename, my $strip)=@_;
	open(my $fh, "<", $filename) or fail("Cannot open file \"$filename\"");
	$/ = undef;
	my $result=readline($fh) or fail("Cannot read file \"$filename\"");
	close($fh);
	if($strip) {
		$result=~s/[\r\n\t]//g;
	}
	return $result;
}
sub parseTheme #returns a pretty little tree of the theme. Considering the function works through the file in order, it should be fairly easy to work on a line-by-line basis in the future instead of slurping up the whole thing at the beginning...
{
	(my $filename, my $strip)=@_;
	my $in=slurp($filename, $strip);
	my $root={ "children" => [] };#outer hash for convenience/consistency
	my $currBlock=$root;
	while((my $match, my $html, my $isBlock, my $closing, my $name) = $in =~ /(^(.*?){((\/)?block:)?([A-z]+)})/s) { #inv0k3 t3h d33p p3rl m4j1ckz
		$in=substr($in,length($match));#remove the part of the string we "consumed" (TODO: possible optimization here????)
		#K NOW LETS STRUCTURE THIS!
		push(@{$currBlock->{"children"}}, $html) if $html;#if we slurped up any HTML lets deal with that before we do anything else
		if(!$isBlock) { #now lets start with the easy case: the token we found is not a block, just an insert thingy.
			push(@{$currBlock->{"children"}}, {
				"name"=>$name
			});
		}
		elsif(!$closing) { #this will be a bit more work. The token we found marks the opening of a block! I guess we have to make a block then ;(
			my $i=push(@{$currBlock->{"children"}}, {
				"name"=>$name,
				"parent"=>$currBlock, #We'll need this later to get out of the block. Don't forget to remove this later to keep things clean!
				"children"=>[]
			});
			$currBlock=$currBlock->{"children"}->[$i-1]; #set currBlock equal to the block we just created
		} #oh. nevermind, that wasn't so bad
		else { #and NOW, DEAR WATSON, through the PROCESS OF ELIMINATION we can DEDUCE that the TOKEN we have STUMPLED ACROSS... MARKS the END of a BLOCK!
			my $oldCurr=$currBlock;
			$currBlock=$currBlock->{"parent"};#now we just pop up one level
			delete($oldCurr->{"parent"});#clean up the parent ref; we don't need it any more
		}
	}
	push(@{$root->{"children"}},$in);#WHOOPS THE PARSING LOOP DIDN'T GRAB THE LAST BIT OF HTML SINCE IT'S NOT FOLLOWED BY A TUMBLR TAG THINGY (TODO: I should really look up what to call those things so i dont sound like an idiot)
	return $root->{"children"};#stip off the outer object
}
sub parseContent
{
	my $filename=shift();
	return decode_json(slurp(path($filename))) or fail("JSON decode failed for file $filename");
}
sub render #render a demo using $content for filler text, etc
{
	(my $block, my $content, my $assets, my $inline, my $strip)=@_;
	if($content->{"PostType"}) {#special case for Posts. Mark the type of post as True so it'll render the correct block TODO: better solution for special cases; there will be a lot of them
		$content->{ucfirst($content->{"PostType"})}=1;
	}
	my $result="";
	foreach my $item (@{$block}) {
		if(ref($item) eq "HASH") {
			$result.=renderObject($item, $content, $assets, $inline, $strip);
		}
		elsif(!($item=~/^[\r\n\s]*$/)){ #don't concatenate if it's just a blank line; that's leftovers from block declarations. TODO: maybe this should be dealt with in the parse function???
			$result.=$item;
		}
	}
	return $result;
}
sub renderObject #used by render to do most of the heavy lifting
{
	(my $block, my $content, my $assets, my $inline, my $strip)=@_;
	if($block->{"children"} and $content->{$block->{"name"}}) { #If the block has children, it's not just a placeholder, it's a block. Check if there is anything to go in the block, and if so, render it.
		if(ref($content->{$block->{"name"}}) eq "ARRAY") {#Is the relevant content an array (eg. posts, tags, etc)?
			my $result="";
			foreach my $contentItem (@{$content->{$block->{"name"}}}) { #iterate over said array
				$result.=render($block->{"children"}, $contentItem, $assets, $inline, $strip); #render the current block for each array item
			}
			return $result;
		}
		else { #No it's not an array; thank goodness. Just render it
			return render($block->{"children"}, $content, $assets, $inline, $strip);
		}
	}
	else { #since it's not a block, it's a placeholder.
		my $result="";
		if($block->{"name"} eq "tumbltool_assets") {
			$result=renderAssets($assets, $inline, $strip);
		}
		else {
			$result=renderText($content, $block); #so we just print the value from content that corresponds to the block's name (if it exists)
		}
		return (($result eq "1")?"":$result); #if the text is just "1" don't print anything though
	}
}
sub renderText
{
	(my $content, my $block)=@_;
	#First, lets extract the prefix, if any
	$block->{"name"}=~/^(Plaintext|JS|JSPlaintext|URLEncoded|RGB)?(.+)$/;
	my $prefix=$1;
	my $name=$2 or $1;
	my $text=date($name, $content->{"Date"}) // $content->{$name};
	return formatText($prefix, $text || "");
}
sub date
{
	(my $name, my $text)=@_;
	my $date=localtime($text);
	my $formats={
		"DayOfMonth"          => "%e",
		"DayOfMonthWithZero"  => "%d",
		"DayOfWeek"           => "%A",
		"ShortDayOfWeek"      => "%a",
		"DayOfWeekNumber"     => "%u",
		"DayOfMonthSuffix"    => "th",
		"DayOfYear"           => "%j",
		"WeekOfYear"          => "%W",
		"Month"               => "%B",
		"ShortMonth"          => "%b",
		"MonthNumber"         => "%e",
		"MonthNumberWithZero" => "%m",
		"Year"                => "%Y",
		"ShortYear"           => "%y",
		"AmPm"                => "%P",
		"CapitalAmPm"         => "%p",
		"12Hour"              => "%I",
		"24Hour"              => "%k",
		"12HourWithZero"      => "%l",
		"24HourWithZero"      => "%H",
		"Minutes"             => "%M",
		"Seconds"             => "%S",
		"Beats"               => "249",
		"Timestamp"           => "%s",
		"TimeAgo"             => "100 years ago",
	};
	my $format=$formats->{$name};
	if($name eq "DayOfMonthSuffix") {
		my $d=$date->strftime("%e");
		return "th" if($d>=11 and $d<=13);
		return "st" if($d % 10 == 1);
		return "nd" if($d % 10 == 2);
		return "rd" if($d % 10 == 3);
		return "th";
	}
	elsif($format) {
		return $date->strftime($format);
	}
	else {
		return;
	}
}
sub jsQuote
{
	my $text=shift();
	$text=~s/\\/\\\\/g;
	$text=~s/'/\\'/g;
	return "'$text'";
}
sub stripHTML
{
	my $text=shift();
	my $hs=HTML::Strip->new(emit_spaces=>0);
	return $hs->parse(encode_entities($text));
}
sub formatText
{
	(my $format, my $text)=@_;
	if($format eq "Plaintext") {
		return stripHTML($text);
	}
	elsif($format eq "JS") {
		return jsQuote($text);
	}
	elsif($format eq "JSPlaintext") {
		return jsQuote(stripHTML($text));
	}
	elsif($format eq "URLEncoded") {
		return uri_escape_utf8($text);
	}
	elsif($format eq "RGB") {
		$text=~/#?(..)(..)(..)/;
		my $r=hex($1);
		my $g=hex($2);
		my $b=hex($3);
		return ("$r,$g,$b");
	}
	else {
		return $text;
	}
}
sub bundle
{
	(my $block, my $assets, my $inline, my $strip)=@_;
	my $result="";
	foreach my $item (@{$block}) {
		if(ref($item) eq "HASH") {
			$result.=bundleObject($item, $assets, $inline, $strip);
		}
		else {
			$result.=$item;
		}
	}
	return $result;
}
sub bundleObject
{
	(my $block, my $assets, my $inline, my $strip)=@_;
	my $name=$block->{"name"};
	if($name eq "tumbltool_includes") {
		return renderAssets($assets, $inline, $strip);
	}
	elsif($block->{"children"}) {
		return "{block:$name".bundle($block->{"children"},$assets,$inline,$strip)."{/block:$name}";
	}
	else {
		return "{$name}";
	}
}
sub renderAssets
{
	(my $assets, my $inline, my $strip)=@_;
	my $result="";
	foreach my $name (@{$assets}) {
		$result.=renderAsset($name, ($inline and !($name=~/^http:\/\/.+$/)), $strip);
	}
	return $result;
}
sub renderAsset
{
	(my $uri, my $inline, my $strip)=@_;
	my $n=$strip?"":"\n";
	my $before="";
	my $after="";
	my $asset=$inline?slurp(path($uri),$strip):$uri;
	if($uri=~/\.css$/){
		$before=$inline?"<style>$n":"<link rel=\"stylesheet\" type=\"text/css\" href=\"";
		$after=$inline?"$n</style>":"\" />";
	}
	elsif($uri=~/\.js$/){
		$before=$inline?"<script>$n":"<script src=\"";
		$after=$inline?"$n</script>":"\"></script>";
	}
	return "$n$before$asset$after$n";
}
sub fail
{
	my $message=shift();
	if($message){
		print("Fatal Error: $message\n");
	}
	print qq{
usage: tumbltool <COMMAND> [OPTIONS]

Test and deploy tumblr themes with ease!

Commands:
preview
                    Print an example page using the theme specified
                    in FILE, filled with example material from a
                    JSON file (see -content)
bundle
                    Bundle up a theme with any needed assets
                    into a single file to be pasted into Tumblr.
                    Useful for a sort of ghetto deployment system.
help
                    Show this help text and exit.
Options:
-c --content: <FILE>
                    specify content to populate the
                    rendered preview page.
-d --dataURI
                    format output as a base64-encoded
                    data URI, meant for piping into a browser (or
                    sending a link to clients I guess)
-i --include: <FILES>
                    specify CSS or Javscript file(s)
                    to add to the theme, included at the special
                    {tumbltool_includes} tag in your theme file
                    (so make sure to add it, presumably at the
                    end of your theme's <head>. Multiple files
                    can be specified as a space-separated list,
                    or this argument can be added multiple
                    times. You can supply absolute paths,
                    relative paths, or URIs.
-l --inline:
                    Include all local files (not URIs though)
                    inline, using <script> or <style> tags,
                    so the preview or bundle is a single,
                    self-contained file. Handy for one-step
                    deployment, but may hurt performance
                    since browsers won't cache stylesheets.
-s --strip
                    Remove unnecessary whitespace. Useful
                    for keeping file sizes down and ease
                    of sharing.
-v --var ATTRIBUTE=VALUE
                    Specify custom variables you may have
                    in your theme. (Not yet implemented)
-t --theme FILE
                    Specify the theme file to
                    preview/bundle.
}
}
